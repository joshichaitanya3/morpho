// Nematic liquid crystal with Q tensor on a disk
// Solved using CG2 elements

import meshgen
import plot
import povray
import optimize4

class QTensor {
  init(K=0.01) {
    self.mesh = nil 
    self.problem = nil 

    self.rho = 1.3 // Density. rho>1 results in the nematic phase
    self.EA = 3 // Anchoring strength
    self.K = K // Bending modulus. K=0.01 yields two +1/2 defects, whereas K=1.0 yields a single +1 defect.

    self.a2 = (1-self.rho) // Coefficient of Tr(Q^2) in the Free energy 
    self.a4 = (1+self.rho)/self.rho^2 // Coefficient of (Tr(Q^2))^2 in the Free energy
  }

  initialMesh() { 
    var dom = CircularDomain([0,0], 1)
    var mg = MeshGen(dom, [-1..1:0.4, -1..1:0.4], quiet=true)
    var m = mg.build()
    m.addgrade(1)
    self.mesh = ChangeMeshDimension(m, 3)
    return self.mesh
  }

  initialField() { 
    self.q_tensor = Field(self.mesh, 
                          fn(x,y,z) Matrix([0.01*random(1), 0.01*random(1)]),
                          finiteelementspace=FiniteElementSpace("CG2", grade=2)
                          )
  }

  initialSelection() {
    self.bnd = Selection(self.mesh, boundary=true)
    self.bnd.addgrade(0) // add point elements
  }

  buildProblem() { 
    // Specify the problem
    self.problem = OptimizationProblem(self.mesh)

    // Define bulk free energy functional
    fn landau(x, q) {
      var qt = q.norm()
      var qt2=qt*qt
      return self.a2*qt2 + self.a4*qt2*qt2
    }
    var bulk = AreaIntegral(landau, self.q_tensor, method={})
    self.problem.addenergy(bulk)

    // Define anchoring energy functional at the boundary
    fn anchoring(x, q) {
      var t = tangent()
      var wxx = t[0]*t[0]-0.5
      var wxy = t[0]*t[1]
      return (q[0]-wxx)^2+(q[1]-wxy)^2
    }
    var anchor = LineIntegral(anchoring, self.q_tensor, method={})
    self.problem.addenergy(anchor, selection=self.bnd, prefactor = self.EA)

    // The elastic energy is the grad-squared of the q-tensor

    fn elasticity(x, q) {
      var g = grad(q)
      return g[0].inner(g[0]) + g[1].inner(g[1]) 
    }

    var elastic = AreaIntegral(elasticity, self.q_tensor, method={})
    self.problem.addenergy(elastic, prefactor = self.K)

    return self.problem
  }

  buildAdapter() { 
    self.adapter = ProblemAdapter(self.problem, self.q_tensor)
    return self.adapter 
  }

  build() { // Setup the problem and return an Adapter
    self.initialMesh()
    self.initialField()
    self.initialSelection()
    self.buildProblem()
    return self.buildAdapter()
  }

  correctMesh() {
    for (id in self.bnd.idlistforgrade(0)) {
      var x = self.mesh.vertexposition(id)
      self.mesh.setvertexposition(id, x/x.norm())
    }
  }

  correctField() {
    if (self.maxgrade(self.q_tensor)<1) return 
    var conn = self.mesh.connectivitymatrix(0, 1)
    for (id in 0...self.mesh.count(1)) {
      var v=conn.rowindices(id)
      self.q_tensor[1,id]=(self.q_tensor[0,v[0]] + self.q_tensor[0,v[1]])/2
    } 
  }

  refine(adaptive=true, lambda=1.7) {
    var srefine

    if (adaptive) {
      // Select elements that have a large contribution to the elastic energy
      var en = GradSq(self.q_tensor).integrand(self.q_tensor)
      var mean = en.sum()/en.count()
      srefine = Selection(self.mesh) // Start with an empty selection
      for (id in 0...en.count()) if (en[0,id]>lambda*mean) srefine[2,id]=true // Identify high (compared to the mean) energy elements
      print "Refining ${srefine.count(2)} elements"
    }

    // Create a mesh refiner
    var mr=MeshRefiner([self.mesh, self.q_tensor, self.bnd])
    var refmap = mr.refine(selection=srefine)
    
    // Use the new mesh and field
    self.mesh = refmap[self.mesh]
    self.q_tensor = refmap[self.q_tensor]
    self.bnd = refmap[self.bnd]

    self.correctMesh()
    self.correctField()

    equiangulate(self.mesh)

    // Remake the problem and the adapter
    self.buildProblem()
    return self.buildAdapter()
  }

  maxgrade(f) { // Finds the maximum grade in a Field
    var shape = f.shape()
    var maxgrade = 0
    for (s, k in shape) if (s>0) maxgrade=k 
    return maxgrade
  }

  visualize() { 
    var mg = self.maxgrade(self.q_tensor)

    // Function to get the director (unit vector n) from the Q-tensor
    fn qtodirector(q) {
      var S = 2*q.norm()
      var Q = q/S
      var nx = sqrt(Q[0]+0.5)
      var ny = abs(Q[1]/nx)
      nx = nx*sign(Q[1])
      return Matrix([nx,ny,0])
    }

    // Function to get the scalar order parameter S from the Q-tensor
    fn qtoorder(q) {
      var S = 2*q.norm()
      return S
    }

    /* Function to visualize a director field
      This function returns a `Graphics()` object that has the director field visualized in the form of cylinders. Here,
      1. m is the mesh
      2. nn is the director field and
      3. dl is the half-length of the cylinders to be drawn. 
      4. aspectratio (optional argument) is the aspect ratio of the cylinders. (default is 0.3 here) */
    fn visualize(m, nn, dl, aspectratio=0.3) {
      var v = m.vertexmatrix()
      var nv = v.dimensions()[1]
      var g = Graphics()
      for (i in 0...nv) {
        var x = v.column(i)
        g.display(Cylinder(x-nn[i]*dl, x+nn[i]*dl, aspectratio=aspectratio))
      }
      if (mg>0) {
        var conn = m.connectivitymatrix(0,1)
        for (id in 0...m.count(1)) {
          var vids = conn.rowindices(id)
          var x = (v.column(vids[0])+v.column(vids[1]))/2
          g.display(Cylinder(x-nn[1,id]*(2*dl/3), x+nn[1,id]*(2*dl/3), aspectratio=aspectratio/2))
        }
      }
      return g
    }

    var nn = Field(self.mesh, Matrix([1,0,0]), grade=self.q_tensor.shape()) // Initialize to some vector
    for (g in 0..mg) for (i in 0...self.mesh.count(g)) {
      nn[g,i]=qtodirector(self.q_tensor[g,i])
    }
    
    var S = Field(self.mesh, 0) // Initialize to a scalar
    for (i in 0...self.mesh.count()) S[i]=qtoorder(self.q_tensor[i])

    var splot = plotfield(S, style="interpolate", colormap = ViridisMap(), scalebar=ScaleBar(posn=[1.2,0,0]))
    var gnn=visualize(self.mesh, nn, 0.05)

    Show(splot+gnn)
  }
}

var example = QTensor()
var adapt = example.build()

for (i in 1..4) {
    if (i>1) adapt = example.refine(adaptive=false)
    var control = LBFGSController(adapt)
    control.optimize(500) 
    example.visualize()
}
